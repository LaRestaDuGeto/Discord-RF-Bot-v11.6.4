const { play } = require("../include/play");
const { MessageEmbed } = require("discord.js");
const ytsr = require("youtube-sr")
module.exports = {
    name: "play",
    aliases: ["p"],
    cooldown: 10,
    description: `Plays a song for you!.`,
    run: async(client, message, args) => {
        if (client.play_command == true) {
            try {
                if (!message.guild) return;
                const { channel } = message.member.voice;
                const serverQueue = message.client.queue.get(message.guild.id);
                if (!channel) return message.channel.send(
                    new MessageEmbed()
                    .setTitle("You Have To Join a \`Voice Channel\` First!")
                    .setColor("RED")).catch(err => {
                    throw new TypeError(err)
                });
                if (serverQueue && channel !== message.guild.me.voice.channel)
                    return message.channel.send(
                        new MessageEmbed()
                        .setTitle(`Iam Only Work In \`${channel.name}\``)
                        .setColor("RED")).catch(err => {
                        throw new TypeError(err)
                    });
                if (!args.length)
                    return message.channel.send(
                        new MessageEmbed()
                        .setTitle(`Please Type URL/NAME`)
                        .setColor("RED")).catch(err => {
                        throw new TypeError(err)
                    });
                message.react("✅").catch(err => {
                    throw new TypeError(err)
                });
                const permissions = channel.permissionsFor(message.client.user);
                if (!permissions.has("CONNECT"))
                    return message.channel.send(
                        new MessageEmbed()
                        .setTitle(`I Need \`CONNECT\` Permissions To Connect The Room!`)
                        .setColor("RED")).catch(err => {
                        throw new TypeError(err)
                    });
                if (!permissions.has("SPEAK"))
                    return message.channel.send(
                        new MessageEmbed()
                        .setTitle("I Need \`SPEAK\` Permissions To Speak In The Room!")
                        .setColor("RED")).catch(err => {
                        throw new TypeError(err)
                    });
                const search = args.join(" ");
                const videoPattern = /^(https?:\/\/)?(www\.)?(m\.)?(youtube\.com|youtu\.?be)\/.+$/gi;
                const urlValid = videoPattern.test(args[0]);
                const queueConstruct = {
                    textChannel: message.channel,
                    channel,
                    connection: null,
                    songs: [],
                    loop: false,
                    volume: 69,
                    filters: [],
                    realseek: 0,
                    playing: true
                };
                let songInfo = null;
                let song = null;
                try {
                    if (serverQueue) {
                        if (urlValid) {
                            message.channel.send(new MessageEmbed().setColor("BLUE")
                                .setDescription(`**Searching 🔍 [\`LINK\`](${args.join(" ")})**`))
                        } else {
                            message.channel.send(new MessageEmbed().setColor("BLUE")
                                .setDescription(`**Searching 🔍 \`${args.join(" ")}\`**`))
                        }
                    } else {
                        queueConstruct.connection = await channel.join();
                        if (urlValid) {
                            message.channel.send(new MessageEmbed().setColor("BLUE")
                                .setDescription(`**Searching 🔍 [\`LINK\`](${args.join(" ")})**`))
                        }
                        queueConstruct.connection.voice.setSelfDeaf(true);
                        queueConstruct.connection.voice.setDeaf(true);
                    }
                } catch (e) {
                    throw new TypeError(e);
                }
                if (urlValid) {
                    try {
                        songInfo = await ytsr.searchOne(search);
                        song = {
                            title: songInfo.title,
                            views: String(songInfo.views).padStart(10, ' '),
                            ago: songInfo.ago,
                            url: songInfo.url,
                            thumbnail: songInfo.thumbnail,
                            duration: songInfo.durationFormatted,
                        };
                    } catch (error) {
                        if (error.statusCode === 403) return message.channel.send(
                            new MessageEmbed()
                            .setTitle("The bot has a lot of pressure, please re-load the bot!")
                            .setColor("RED")).catch(err => {
                            throw new TypeError(err)
                        });
                        console.error(error);
                        return message.channel.send(`Error: البوت مفشوخ`);
                    }
                } else {
                    try {

                        songInfo = await ytsr.searchOne(search);
                        song = {
                            title: songInfo.title,
                            views: String(songInfo.views).padStart(10, ' '),
                            ago: songInfo.ago,
                            url: songInfo.url,
                            thumbnail: songInfo.thumbnail,
                            duration: songInfo.durationFormatted,
                        };

                    } catch (error) {
                        console.error(error);
                        return message.channel.send(
                            new MessageEmbed()
                            .setTitle(error)
                            .setColor("RED")).catch(err => {
                            throw new TypeError(err)
                        });
                    }
                }
                let thumb = "https://cdn.discordapp.com/attachments/748095614017077318/769672148524335114/unknown.png"
                if (song.thumbnail === undefined) thumb = "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fimages.designtrends.com%2Fwp-content%2Fuploads%2F2016%2F04%2F06131325%2FSnoopy-Playing-Music-Image.jpg&f=1&nofb=1";
                else thumb = song.thumbnail.url;
                if (serverQueue) {
                    let estimatedtime = Number(0);
                    for (let i = 0; i < serverQueue.songs.length; i++) {
                        let minutes = serverQueue.songs[i].duration.split(":")[0];
                        let seconds = serverQueue.songs[i].duration.split(":")[1];
                        estimatedtime += (Number(minutes) * 60 + Number(seconds));
                    }
                    if (estimatedtime > 60) {
                        estimatedtime = Math.round(estimatedtime / 60 * 100) / 100;
                        estimatedtime = estimatedtime + " Minutes"
                    } else if (estimatedtime > 60) {
                        estimatedtime = Math.round(estimatedtime / 60 * 100) / 100;
                        estimatedtime = estimatedtime + " Hours"
                    } else {
                        estimatedtime = estimatedtime + " Seconds"
                    }
                    serverQueue.songs.push(song);

                    if (song.title == undefined || null) song.title == "NIRO";
                    if (estimatedtime == undefined || null) estimatedtime == "NIRO";
                    if (serverQueue.songs.length == undefined || null) serverQueue.songs.length == Number("NIRO");
                    if (song.duration == undefined || null) song.duration == Number("NIRO");
                    if (song.views == undefined || null) song.views == Number("NIRO");
                    if (song.ago == undefined || null) song.ago == Number("NIRO");

                    const newsong = new MessageEmbed()
                        .setTitle("✅ " + song.title)
                        .setColor("BLUE")
                        .setThumbnail(thumb)
                        .setURL(song.url)
                        .setDescription(`\`\`\`Has been added to the Queue.\`\`\``)
                        .addField("Estimated time until playing:", `\`${estimatedtime}\``, true)
                        .addField("Position in queue", `**\`${serverQueue.songs.length - 1}\`**`, true)
                        .addField(`duration`, `**\`${song.duration}\`**`, true)
                        .addField(`Views`, `**\`${song.views}\`**`, true)
                        .setFooter(`Requested by: ${message.author.tag}`, message.member.user.displayAvatarURL({ dynamic: true }))
                    return serverQueue.textChannel
                        .send(newsong)
                        .catch(err => {
                            throw new TypeError(err)
                        });

                }

                queueConstruct.songs.push(song);
                message.client.queue.set(message.guild.id, queueConstruct);
                try {
                    play(queueConstruct.songs[0], message, client);
                } catch (error) {
                    console.error(error);
                    message.client.queue.delete(message.guild.id);
                    return message.channel.send(
                        new MessageEmbed()
                        .setTitle(`Could not join the channel: ${error}`)
                        .setColor("RED")).catch(err => {
                        throw new TypeError(err)
                    });
                }
            } catch (error) {
                throw new TypeError(error)
            }
        } else if (client.help_command == false) {
            message.channel.send(
                new MessageEmbed()
                .setTitle(`\`${module.exports.name}\` Has Been Disabled From The Music System`)
            )
        } else throw new TypeError(`❌ | "${module.exports.name}_command" value must be true or false`)
    }
}