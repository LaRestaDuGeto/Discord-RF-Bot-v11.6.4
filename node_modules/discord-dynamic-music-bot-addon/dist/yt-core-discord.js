"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore no types
const ytdl = __importStar(require("ytdl-core"));
// @ts-ignore no types
const ytsr_1 = __importDefault(require("ytsr"));
// @ts-ignore no types
const ytpl_1 = __importDefault(require("ytpl"));
// @ts-ignore
const prism_media_1 = require("prism-media");
function filter(format) {
    return format.codecs === 'opus' &&
        format.container === 'webm' &&
        format.audioSampleRate ? parseInt(format.audioSampleRate) === 48000 : false;
}
function nextBestFormat(formats) {
    formats = formats
        .filter(format => format.audioSampleRate)
        .sort((a, b) => parseInt(b.audioSampleRate) - parseInt(a.audioSampleRate));
    return formats.find(format => !format.bitrate) || formats[0];
}
async function getYTInfo(url) {
    return await ytdl.getInfo(url);
}
exports.getYTInfo = getYTInfo;
function getStream(info, options = {}) {
    const lengthSeconds = parseInt(info.length_seconds);
    const format = info.formats.find(filter);
    const canDemux = format && lengthSeconds !== 0;
    if (canDemux)
        options = Object.assign(Object.assign({}, options), { filter, highWaterMark: 1 << 25 });
    else if (lengthSeconds !== 0)
        options = { filter: 'audioonly' };
    if (canDemux) {
        const demuxer = new prism_media_1.opus.WebmDemuxer();
        const webmDemuxer = ytdl.downloadFromInfo(info, options)
            .pipe(demuxer)
            .on('end', () => demuxer.destroy());
        return webmDemuxer;
    }
    else {
        const transcoder = new prism_media_1.FFmpeg({
            args: [
                '-reconnect', '1',
                '-reconnect_streamed', '1',
                '-reconnect_delay_max', '5',
                '-i', nextBestFormat(info.formats).url,
                '-analyzeduration', '0',
                '-loglevel', '0',
                '-f', 's16le',
                '-ar', '48000',
                '-ac', '2',
            ],
        });
        const opusEncoder = new prism_media_1.opus.Encoder({ rate: 48000, channels: 2, frameSize: 960 });
        const stream = transcoder.pipe(opusEncoder);
        stream.on('close', () => {
            transcoder.destroy();
            opusEncoder.destroy();
        });
        return stream;
    }
}
exports.getStream = getStream;
async function getVideoInfoPlusStream(url, options = {}) {
    const videoInfo = await getYTInfo(url);
    return getStream(videoInfo, options);
}
exports.getVideoInfoPlusStream = getVideoInfoPlusStream;
async function searchYTVideo(query) {
    let results = await ytsr_1.default(query, { limit: 10 });
    results = results.items.filter((r) => r.type === 'video');
    if (results[0]) {
        const result = await getYTInfo(results[0].link);
        if (!result.length_seconds)
            throw new Error('Missing data fetched from video.');
        if (!result.title)
            throw new Error('Missing data fetched from video.');
        return result;
    }
    else {
        throw new Error('Nothing found');
    }
}
exports.searchYTVideo = searchYTVideo;
async function parsePlaylist(IDorURL) {
    return await ytpl_1.default(IDorURL);
}
exports.parsePlaylist = parsePlaylist;
//# sourceMappingURL=yt-core-discord.js.map